
precision mediump float;

uniform sampler2D u_Texture;

uniform vec4 u_LightingParameters;
uniform vec4 u_MaterialParameters;
uniform float u_transparency;

varying vec3 v_ViewPosition;
varying vec3 v_ViewNormal;
varying vec2 v_TextureCoord;

// Light
uniform lowp vec4 u_nglLightColor;

uniform mediump float u_nglShininess;

varying highp vec3 v_nglVEye;
varying highp vec3 v_nglVLight;
varying lowp float v_nglLightLevel;

// local variables
lowp vec4 _nglEmission = vec4(0.0);
lowp vec4 _nglAmbient = vec4(0.0);
lowp vec4 _nglDiffuse = vec4(0.0);
lowp vec4 _nglSpecular = vec4(0.0);
lowp vec4 _nglLightF = vec4(1.0);
lowp float _nglShineF = 1.0;
lowp float _nglAlpha = 1.0;

void main() {
    
    // if not obj model
    if(1 == 1){
        const float kGamma = 0.4545454;
        const float kInverseGamma = 2.2;
        
        // vec3 viewFragmentDirection = normalize(v_ViewPosition);
        vec3 viewNormal = normalize(v_ViewNormal);
        // vec3 viewLightDirection = u_LightingParameters.xyz;

        vec4 diffuseColor = vec4(0.5, 0.5, 0.7, 1.0);
//
//        vec3 reflectedLightDirection = reflect(viewLightDirection, viewNormal);
//        float specularStrength = max(0.0, dot(viewFragmentDirection, reflectedLightDirection));
        

        
        //**************************************************
        //    Global Effects
        //**************************************************
        
        //*************************
        //    Fog
        
//        addShaderElement(VSH_FOG, shaders.vertex);
//        addShaderElement(FSH_FOG, shaders.fragment);
        //*************************

        
        //*************************
        //    Shader Technique
        //*************************
        
        // addShaderElement(FSH_FINAL, shaders.fragment);
        
        //**************************************************
        //    Special Effects Using Lights
        //**************************************************
        
        //*************************
        //    Shininess
        //*************************
//            addShaderElement(FSH_SHININESS, shaders.fragment);

        
        //*************************
        //    Specular
        //*************************
//        {
//            addShaderElement(FSH_SPECULAR_COLOR, shaders.fragment);

        
        //*************************
        //    Alpha Test
        //*************************
            // Alpha test is made right after the Light Mapping.
            // addShaderElement(FSH_ALPHA_TEST, shaders.fragment);
        
        //**************************************************
        //    Basic Effects
        //**************************************************
        
        //*************************
        //    Alpha
        //*************************
//        if (alphaEnabled)
//        {
//                addShaderElement(FSH_ALPHA, shaders.fragment);
//        }
        
        //*************************
        //    Ambient Illumination
        //*************************
        //    addShaderElement(FSH_AMBIENT_COLOR, shaders.fragment);

        //    Diffuse
        // _nglDiffuse = texture2D(u_Texture, v_TextureCoord);
        _nglDiffuse = texture2D(u_Texture, vec2(v_TextureCoord.x, 1.0 - v_TextureCoord.y)); // invert texture
        //*************************
        //    Emissive Illumination
        //*************************
//             addShaderElement(FSH_EMISSIVE_COLOR, shaders.fragment);
        
        //*************************
        //    Light
        //*************************
        lowp vec3 _nglVEye = normalize(v_nglVEye);
        lowp vec3 _nglVLight = normalize(v_nglVLight);
        
        vec3 nglNormal = viewNormal; // LINEAR_MAP
        // nglNormal = normalize(_nglDiffuse.rgb * 2.0 - 1.0); // BUMP_MAP
        // Phong
        lowp float _nglLightD = max(dot(nglNormal, _nglVLight), 0.0) + 0.4; // 0.2: back face also has light
        lowp float _nglShineD = max(dot(2.0 * nglNormal * _nglLightD - _nglVLight, _nglVEye), 0.0);
        
        _nglLightF = u_nglLightColor * v_nglLightLevel * _nglLightD;

        // Specular
//        _nglSpecular = u_nglLightColor * v_nglLightLevel; // u_nglSpecularColor
//        _nglShineF = pow(_nglShineD, 10);
        
        //    Base
        gl_FragColor = _nglEmission + _nglAmbient + _nglDiffuse * _nglLightF ;// + _nglSpecular * _nglShineF;
//        gl_FragColor.a = _nglAlpha * _nglDiffuse.a;
//
        // We support approximate sRGB gamma.


        // Unpack lighting and material parameters for better naming.
        vec3 viewLightDirection = u_LightingParameters.xyz;
        float lightIntensity = u_LightingParameters.w;
//
        float materialAmbient = u_MaterialParameters.x;
        float materialDiffuse = u_MaterialParameters.y;
        float materialSpecular = u_MaterialParameters.z;
        float materialSpecularPower = u_MaterialParameters.w;
//
//        // Normalize varying parameters, because they are linearly interpolated in the vertex shader.
        
//        vec3 viewNormal = normalize(v_ViewNormal);
//
//        // Apply inverse SRGB gamma to the texture before making lighting calculations.
//        // Flip the y-texture coordinate to address the texture from top-left.
        vec4 objectColor = texture2D(u_Texture, vec2(v_TextureCoord.x, 1.0 - v_TextureCoord.y));
        objectColor.rgb = pow(objectColor.rgb, vec3(kInverseGamma));
//
//        // Ambient light is unaffected by the light intensity.
        float ambient = materialAmbient;
//
//        // Approximate a hemisphere light (not a harsh directional light).
        float diffuse = lightIntensity * materialDiffuse * 0.5 * (dot(viewNormal, viewLightDirection) + 1.0);
//
//        // Compute specular light.
        vec3 reflectedLightDirection = reflect(viewLightDirection, viewNormal);
        vec3 viewFragmentDirection = _nglVEye;// normalize(v_ViewPosition);
        float specularStrength = max(0.0, dot(viewFragmentDirection, reflectedLightDirection));
        float specular = lightIntensity * materialSpecular * pow(specularStrength, materialSpecularPower);
//
//        // Apply SRGB gamma before writing the fragment color.
//
//        gl_FragColor.rgb = pow(objectColor.rgb * (ambient + diffuse) + specular, vec3(kGamma));
//        gl_FragColor.a = u_transparency;
        
    } else { // obj model
        // We support approximate sRGB gamma.
//        const float kGamma = 0.4545454;
//        const float kInverseGamma = 2.2;
//
//        // Unpack lighting and material parameters for better naming.
//        vec3 viewLightDirection = u_LightingParameters.xyz;
//        float lightIntensity = u_LightingParameters.w;
//
//        float materialAmbient = u_MaterialParameters.x;
//        float materialDiffuse = u_MaterialParameters.y;
//        float materialSpecular = u_MaterialParameters.z;
//        float materialSpecularPower = u_MaterialParameters.w;
//
//        // Normalize varying parameters, because they are linearly interpolated in the vertex shader.
//        vec3 viewFragmentDirection = normalize(v_ViewPosition);
//        vec3 viewNormal = normalize(v_ViewNormal);
//
//        // Apply inverse SRGB gamma to the texture before making lighting calculations.
//        // Flip the y-texture coordinate to address the texture from top-left.
//        vec4 objectColor = texture2D(u_Texture, vec2(v_TextureCoord.x, 1.0 - v_TextureCoord.y));
//        objectColor.rgb = pow(objectColor.rgb, vec3(kInverseGamma));
//
//        // Ambient light is unaffected by the light intensity.
//        float ambient = materialAmbient;
//
//        // Approximate a hemisphere light (not a harsh directional light).
//        float diffuse = lightIntensity * materialDiffuse * 0.5 * (dot(viewNormal, viewLightDirection) + 1.0);
//
//        // Compute specular light.
//        vec3 reflectedLightDirection = reflect(viewLightDirection, viewNormal);
//        float specularStrength = max(0.0, dot(viewFragmentDirection, reflectedLightDirection));
//        float specular = lightIntensity * materialSpecular * pow(specularStrength, materialSpecularPower);
//
//        // Apply SRGB gamma before writing the fragment color.
//        gl_FragColor.a = u_transparency;
//        gl_FragColor.rgb = pow(objectColor.rgb * (ambient + diffuse) + specular, vec3(kGamma));
    }
}
